# reviewer-assignment-service
<div align="center"> Сервис, который назначает ревьюеров на PR из команды автора, позволяет выполнять переназначение ревьюверов и получать список PR’ов, назначенных конкретному пользователю, а также управлять командами и активностью пользователей</div>

![а это забавные котики](images/funnyCatsForREADME.jpg)

## Комментарии к коду и обоснование решений

<div style="font-style: italic; color: #FF4BD680;">
Очень надеюсь, что не будет звучать грубо или слишком дотошно, просто в ридми к тестовому просили описать, где возникли сомнения, а также причины, по которым было принято то или иное решение, поэтому я подумала, что просто немного адаптировать будет как минимум некрасиво, как максимум значительно усложнит проверку и введет в ступор проверяющих
</div>

Обращу внимание сразу, что я отошла от требований в openapi.yml (https://github.com/avito-tech/tech-internship/blob/main/Tech%20Internships/Backend/Backend-trainee-assignment-autumn-2025/openapi.yml)

**Исходные требования:** `string` для идентификаторов  
**Мое решение:** `int` с автоинкрементом

Мне показалось неуместным использование `string` для `id`, поэтому в работе я заменила на `int` по ряду причин:

* `id` - уникальный идентификатор, который можно использовать в качестве `primary key` в базе данных 
* так или иначе нам необходим автоинрементирующийся атрибут для связи таблиц друг с другом - тогда этот атрибут с уникальным `id` в формате `string` вместе будут излишними
* если не использовать `int` для `id` (который будет генерироваться при добавлении объекта в базу - просто инкриминируется и тогда гарантированно мы получаем уникальный идентификатор), то все еще не стоит использовать `string` - поскольку тогда придется проходиться по всей базе и проверять на уникальность, либо создавать свою хеш-мапу, чтобы за o(1) проверять его уникальность, а затем продумывать способ обработки коллизий, в то время как есть готовое решение - `uuid`

Немного резюмируя, использование `string` мне кажется неправильным, лучше всего использовать `uuid`, но это влечет за собой громоздкие трудно читаемые конструкции в коде, а `int` - компромиссное решение, корректно работает, гарантирует уникальные значения, не мешает при проверке:)

То же самое, но более наглядно!

| Проблема | Решение | Преимущество |
|----------|---------|--------------|
| Необходимость уникального primary key | `int` с автоинкрементом | Гарантированная уникальность |
| Избыточность string ID + автоинкремент | Единый идентификатор | Упрощение структуры БД |
| Сложность проверки уникальности string | Готовая система инкремента | Эффективность O(1) |

---

И небольшая заметка! Для реализации репозиториев я использовала бибилиотеку `github.com/Masterminds/squirrel` (подробнее можно почитать вот тут: https://github.com/Masterminds/squirrel)

Она позволяет генерировать SQL-запросы в Go с использованием методов цепочки, что делает код значительно более читаемым! 

В конструкторе репозиториев я использовала `squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar)` для генерации SQL-запросов с использованием `$` - поскольку до этого выбрала PostgreSQL в качестве БД, в которой через дефолтный `?` обращение к параметрам запроса не поддерживается


Возможно, у вас возникнет несколько вопросов, поэтому немного моих комментариев к коду!

1) почему при составлении мемберов (`[]Members`) команды я джоиню таблицу юзеров (`users`) и таблицу тимов (`teams`)?
2) зачем тогда нужна таблица мемберов (`team_members`)?

        1) один юзер может быть в 1 команде, название команды уникально -> когда мы джоиним мы получаем информацию о юзерах, которые находятся в той или иной команде, а мембер - тот же юзер, но не содержит почту юзера и хранит информацию об айди команды
   
        2) таблица мемберов нужна для более легкого поиска активных юзеров в команде при назначении ревьювера


*Немного справочной информации для понимания http ответов:*

* `100` - `199` - информационные ответы
* `200` - `299` - успешные ответы
* `300` - `399` - сообщения о перенаправлении
* `400` - `499` - ошибки клиента
* `500` - `599` - ошибки сервера

Более конкрeтно об использованных кодах:

| **код** | **описание**         |
|---------|----------------------|
| 200     | обновлена информация |
| 201     | создан новый объект  |
| 204     | нет контента         |
| 404     | объект не найден     |
| 409     | объект уже создан    |


И снова постараюсь ответить на возможные вопросы:)

        Для наших ручек (`handlers`) необходим роутер, он выполняет следующие функции:
        - Маршрутизирует HTTP запросы к соответствующим обработчикам
        - Группирует связанные эндпоинты
        - Применяет middleware (аутентификация, логирование, CORS)
        - Обрабатывает CORS и другие cross-cutting concerns
        - Валидирует структуру URL
        - Обеспечивает согласованность API

Есть несколько вариантов, как реализовать роутер, давайте их разберем и я обосную свое решение!

(опиралась на статью на хабре: https://habr.com/ru/companies/otus/articles/653009/)

1. https://pkg.go.dev/net/http#ServeMux - http.ServeMux
2. https://github.com/julienschmidt/httprouter - julienschmidt/httprouter
3. https://github.com/go-chi/chi - go-chi/chi
4. https://github.com/gorilla/mux - gorilla/mux

| роутер                   | описание                                                                                                  | преимущества                                                                                                                                                                                                                                                                                                                                                                            | недостатки                                                                                                                                                                                                                                            |
|--------------------------|-----------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| http.ServeMux            | стандартный роутер в Go (входит в стандартную библиотку -> нет необходимости внедрять новые зависимости ) | поддерживает маршруты на основе хоста, URL входящих запросов автоматически санируются, способ сопоставления маршрутов интеллектуален: более длинные шаблоны маршрутов всегда имеют приоритет над более короткими. В результате можно регистрировать шаблоны в любом порядке, и это не изменит поведение  приложения                                                                     | не поддерживает маршрутизацию на основе методов или переменные в URL-путях                                                                                                                                                                            |
| julienschmidt/httprouter | сторонний роутер                                                                                          | автоматически обрабатывает OPTIONS запросы и корректно отправляет 405, позволяет устанавливать собственные обработчики для ответов 404 и 405                                                                                                                                                                                                                                            | не поддерживает маршруты на основе хоста, пользовательские правила маршрутизации или шаблоны маршрутов на основе регулярных выражений. Также важно отметить, что httprouter не допускает конфликтующих маршрутов, таких как /post/create и /post/:id, |
| go-chi/chi               | сторонний роутер                                                                                          | поддерживает маршрутизацию на основе методов, переменные в URL-путях и шаблоны маршрутов на основе регулярных выражений, позволяет устанавливать собственные обработчики ответов 404 и 405, можно создавать “группы” маршрутов, которые используют определенное middleware, разрешает конфликтующие маршруты, и при этом маршруты сопоставляются в том порядке, в котором они объявлены | не обрабатывает OPTIONS запросы и не устанавливает заголовок Allow в ответах 405                                                                                                                                                                      |
| gorilla/mux              | сторонний роутер                                                                                          | поддерживает пользовательские правила маршрутизации и “реверсирование” маршрута, позволяет устанавливать собственные обработчики для ответов 404 и 405                                                                                                                                                                                                                                  | не обрабатывает OPTIONS запросы и не включает заголовок  Allow в 405 ответы                                                                                                                                                                           |

Я выбрала `chi`, так как он очень похож на `gorilla/mux`, но у меня не было необходимости в пользовательских правилах маршрутизации и “реверсировании” маршрута -> главное отличие от `chi` не использовалось бы, значит, он был бы излишним

---


## Подробная инструкция к запуску приложения и примеры использования!

*Команда для запуска приложения*

```bash
docker compose up --build
```

*При необходимости можно остановить контейнеры и удалить вольюмы*

```bash
docker compose down -v
```

---

<div align="center" style="font-style: italic; color: #FF4BD680;">
✨Спасибо большое, что прочитали и просмотрели мою работу! И за само задание, разумеется, тоже! Было очень интересно! :) ✨
</div>



<div style="font-style: italic; color: #FF4BD680;">
И милая картинка для восстановления настроения и сил!!
</div>

![Теплая добрая картинка](images/meow.jpg)